// File: jpeg_top.v
// Generated by MyHDL 0.9dev
// Date: Tue Nov  4 15:23:17 2014


`timescale 1ns/10ps

module jpeg_top (
    clk_fast,
    offset,
    dout_rom,
    addr_rom,
    jp_lf,
    jp_sa,
    jp_rh,
    jp_flgs,
    reset_n,
    rdy,
    sig_out,
    sig_in,
    noupdate_s,
    res_s,
    state_r,
    reset_fsm_r,
    addr_res,
    offset_r
);


input clk_fast;
output [11:0] offset;
reg [11:0] offset;
input [15:0] dout_rom;
output [11:0] addr_rom;
reg [11:0] addr_rom;
output [15:0] jp_lf;
reg [15:0] jp_lf;
output [15:0] jp_sa;
reg [15:0] jp_sa;
output [15:0] jp_rh;
reg [15:0] jp_rh;
output [3:0] jp_flgs;
reg [3:0] jp_flgs;
output reset_n;
reg reset_n;
output rdy;
reg rdy;
output [51:0] sig_out;
reg [51:0] sig_out;
input [51:0] sig_in;
output noupdate_s;
reg noupdate_s;
output signed [15:0] res_s;
reg signed [15:0] res_s;
output [2:0] state_r;
reg [2:0] state_r;
input reset_fsm_r;
output [8:0] addr_res;
reg [8:0] addr_res;
input [11:0] offset_r;






always @(posedge clk_fast) begin: JPEG_TOP_INSTANCE_1_TEST_PROCESS
    if (reset_n) begin
        jp_lf <= 0;
        jp_sa <= 0;
        jp_rh <= 0;
        if ((jp_flgs[0] == 1)) begin
            addr_rom <= (1 + offset);
        end
        else begin
            addr_rom <= (0 + offset);
        end
    end
    else begin
        if (jp_flgs[0]) begin
            if ((addr_rom == (1 + offset))) begin
                jp_lf <= dout_rom;
                addr_rom <= (addr_rom + 1);
            end
            else begin
                if ((addr_rom == (2 + offset))) begin
                    jp_sa <= dout_rom;
                    addr_rom <= (addr_rom + 1);
                end
                else begin
                    if ((addr_rom == (3 + offset))) begin
                        jp_rh <= dout_rom;
                    end
                end
            end
        end
        else if ((addr_rom == (0 + offset))) begin
            jp_lf <= dout_rom;
            addr_rom <= (addr_rom + 1);
        end
        else begin
            if ((addr_rom == (1 + offset))) begin
                jp_sa <= dout_rom;
                addr_rom <= (addr_rom + 1);
            end
            else begin
                if ((addr_rom == (2 + offset))) begin
                    jp_rh <= dout_rom;
                end
            end
        end
    end
end


always @(jp_sa, jp_flgs, jp_lf, rdy, jp_rh) begin: JPEG_TOP_INSTANCE_2_LOGIC
    if (rdy) begin
        sig_out = {jp_flgs, jp_rh, jp_sa, jp_lf};
    end
    else begin
        sig_out = 0;
    end
end


always @(posedge clk_fast) begin: JPEG_TOP_INSTANCE_3_JPEG
    if (sig_in[50]) begin
        noupdate_s <= 0;
        if (sig_in[48]) begin
            if (sig_in[49]) begin
                res_s <= (sig_in[32-1:16] - ((sig_in[16-1:0] >>> 1) + (sig_in[48-1:32] >>> 1)));
            end
            else begin
                res_s <= (sig_in[32-1:16] + ((sig_in[16-1:0] >>> 1) + (sig_in[48-1:32] >>> 1)));
            end
        end
        else begin
            if (sig_in[49]) begin
                res_s <= (sig_in[32-1:16] + (((sig_in[16-1:0] + sig_in[48-1:32]) + 2) >>> 2));
            end
            else begin
                res_s <= (sig_in[32-1:16] - (((sig_in[16-1:0] + sig_in[48-1:32]) + 2) >>> 2));
            end
        end
    end
    else begin
        noupdate_s <= 1;
    end
end


always @(state_r, offset_r, reset_fsm_r) begin: JPEG_TOP_INSTANCE_4_FSM
    if ((reset_fsm_r == 0)) begin
        // The start up value for reset_n is 1 |__
        // Need to added after 70 ns to the line below
        // which will total 80 ns 
        // cut after 70 ns and paste in the line below  
        addr_res = (offset_r + 1);
        reset_n = 0;
        state_r = 3'b001;
    end
    else begin
        casez (state_r)
            3'b??1: begin
                rdy = 1;
                jp_flgs = 6;
                offset = offset_r;
                // The start up value for reset_n is 1 |__
                // Need to added after 70 ns to the line below
                // which will total 80 ns
                // rdy needs to go hi 30 ns after reset_n goes lo
                // rdy needs go lo 10 ns before reset_n goes hi
                // cut after 70 ns and paste in the line below 
                reset_n = 1;
                // The start up value for rdy is 0 __|
                // rdy needs to go hi 10 ns after reset_n goes lo
                // rdy needs go lo 10 ns before reset_n goes hi
                // cut after 60 ns and paste in the line below 
                rdy = 0;
                state_r = 3'b001;
            end
            3'b?1?: begin
                jp_flgs = 7;
                state_r = 3'b001;
            end
            3'b1??: begin
                state_r = 3'b001;
            end
            default: begin
                $finish;
            end
        endcase
    end
end

endmodule
