-- File: xess_jpeg_top.vhd
-- Generated by MyHDL 0.9dev
-- Date: Wed Feb 11 19:55:44 2015



package pck_xess_jpeg_top is

attribute enum_encoding: string;

    type t_enum_t_State_1 is (
    INIT,
    READ_ROM_TO_FIFO,
    COPY_PG1_TO_PG2,
    WRITE_FIFO_TO_SDRAM,
    WRITE_HI_BYTE,
    WRITE_LO_BYTE,
    READ_HI_AND_SUM_DATA,
    READ_LO_AND_SUM_DATA,
    CK_SDRAM_RD,
    CK_SDRAM_WR,
    ODD_SAMPLES,
    EVEN_SAMPLES,
    WR_DATA,
    INTERLACE,
    DONE
);
attribute enum_encoding of t_enum_t_State_1: type is "000000000000001 000000000000010 000000000000100 000000000001000 000000000010000 000000000100000 000000001000000 000000010000000 000000100000000 000001000000000 000010000000000 000100000000000 001000000000000 010000000000000 100000000000000";

end package pck_xess_jpeg_top;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_09.all;

use work.pck_xess_jpeg_top.all;

entity xess_jpeg_top is
    port (
        clk_fast: in std_logic;
        addr0_r: inout unsigned(23 downto 0);
        addr0_x: inout unsigned(23 downto 0);
        addr1_r: inout unsigned(23 downto 0);
        addr1_x: inout unsigned(23 downto 0);
        state_r: inout t_enum_t_State_1;
        state_x: inout t_enum_t_State_1;
        dataToRam0_r: inout unsigned(31 downto 0);
        dataToRam0_x: inout unsigned(31 downto 0);
        dataFromRam0_r: inout unsigned(31 downto 0);
        dataFromRam0_x: inout unsigned(31 downto 0);
        dataToRam1_r: inout unsigned(31 downto 0);
        dataToRam1_x: inout unsigned(31 downto 0);
        dataFromRam1_r: inout unsigned(31 downto 0);
        dataFromRam1_x: inout unsigned(31 downto 0);
        reset_col: out std_logic;
        offset_r: inout unsigned(23 downto 0);
        offset_x: inout unsigned(23 downto 0);
        dataFromRam0_s: in unsigned(31 downto 0);
        dataFromRam1_s: in unsigned(31 downto 0);
        done1_s: in std_logic;
        wr1_s: out std_logic;
        rd1_s: out std_logic;
        done0_s: in std_logic;
        wr0_s: out std_logic;
        rd0_s: out std_logic;
        sum_r: inout unsigned(31 downto 0);
        sum_x: inout unsigned(31 downto 0);
        empty_r: out std_logic;
        full_r: out std_logic;
        enr_r: inout std_logic;
        enw_r: inout std_logic;
        dataout_r: inout unsigned(31 downto 0);
        datain_r: inout unsigned(31 downto 0);
        empty_x: inout std_logic;
        full_x: inout std_logic;
        enr_x: inout std_logic;
        enw_x: inout std_logic;
        dataout_x: inout unsigned(31 downto 0);
        datain_x: inout unsigned(31 downto 0);
        col_r: inout unsigned(7 downto 0);
        col_x: inout unsigned(7 downto 0);
        row_r: inout unsigned(7 downto 0);
        row_x: inout unsigned(7 downto 0);
        dout_rom: inout unsigned(31 downto 0);
        addr_rom_r: inout unsigned(3 downto 0);
        addr_rom_x: inout unsigned(3 downto 0);
        index1_r: inout unsigned(23 downto 0);
        index2_r: inout unsigned(23 downto 0);
        index3_r: inout unsigned(23 downto 0);
        index1_x: inout unsigned(23 downto 0);
        index2_x: inout unsigned(23 downto 0);
        index3_x: inout unsigned(23 downto 0)
    );
end entity xess_jpeg_top;
-- The following between the single quotes ':= "0000"' needs to added to line below
-- signal instance_1_reset_ctn: unsigned(3 downto 0);
-- before the ';' to be like the following
-- signal instance_1_reset_ctn: unsigned(3 downto 0):= "0000";
--  

architecture MyHDL of xess_jpeg_top is


constant ASZ: integer := 4;
constant YES: integer := 1;
constant reset_dly_c: integer := 10;
constant NO: integer := 0;



signal instance_1_readptr: unsigned(3 downto 0);
signal instance_1_reset_ctn: unsigned(3 downto 0):= "0000";
signal instance_1_writeptr: unsigned(3 downto 0);
type t_array_instance_1_mem is array(0 to 16-1) of unsigned(31 downto 0);
signal instance_1_mem: t_array_instance_1_mem;

begin




XESS_JPEG_TOP_INSTANCE_1_RTL: process (clk_fast) is
begin
    if rising_edge(clk_fast) then
        if (instance_1_reset_ctn < reset_dly_c) then
            instance_1_readptr <= to_unsigned(0, 4);
            instance_1_writeptr <= to_unsigned(0, 4);
            instance_1_reset_ctn <= (instance_1_reset_ctn + 1);
        end if;
        if (enr_r = '1') then
            dataout_x <= instance_1_mem(to_integer(instance_1_readptr));
            instance_1_readptr <= (instance_1_readptr + 1);
        end if;
        if (enw_r = '1') then
            instance_1_mem(to_integer(instance_1_writeptr)) <= datain_x;
            instance_1_writeptr <= (instance_1_writeptr + 1);
        end if;
        if (signed(resize(instance_1_readptr, 5)) = ((2 ** ASZ) - 1)) then
            instance_1_readptr <= to_unsigned(0, 4);
        end if;
        if (signed(resize(instance_1_writeptr, 5)) = ((2 ** ASZ) - 1)) then
            full_x <= '1';
            instance_1_writeptr <= to_unsigned(0, 4);
        else
            full_x <= '0';
        end if;
        if (instance_1_writeptr = 0) then
            empty_x <= '1';
        else
            empty_x <= '0';
        end if;
    end if;
end process XESS_JPEG_TOP_INSTANCE_1_RTL;


XESS_JPEG_TOP_INSTANCE_6_FSM: process (dout_rom, addr0_r, addr1_r, row_r, done1_s, state_r, done0_s, dataout_r, offset_r, dataToRam1_r, dataToRam0_r, addr_rom_r, datain_r, enr_r, col_r, sum_r, index1_r, dataFromRam0_s, dataFromRam0_r, index2_r, dataFromRam1_r, dataFromRam1_s, index3_r, enw_r) is
    variable TEST1: unsigned(23 downto 0);
    variable TEST3: unsigned(23 downto 0);
    variable TEST2: unsigned(23 downto 0);
begin
    TEST1 := index1_r;
    TEST2 := index2_r;
    TEST3 := index3_r;
    addr0_x <= addr0_r;
    addr1_x <= addr1_r;
    state_x <= state_r;
    sum_x <= sum_r;
    wr0_s <= '0';
    rd0_s <= '0';
    wr1_s <= '0';
    rd1_s <= '0';
    dataToRam0_x <= dataToRam0_r;
    dataToRam1_x <= dataToRam1_r;
    dataFromRam0_x <= dataFromRam0_r;
    dataFromRam1_x <= dataFromRam1_r;
    enr_x <= enr_r;
    enw_x <= enw_r;
    datain_x <= datain_r;
    offset_x <= offset_r;
    col_x <= col_r;
    row_x <= row_r;
    addr_rom_x <= addr_rom_r;
    index1_x <= index1_r;
    index2_x <= index2_r;
    index3_x <= index3_r;
    if (state_r = INIT) then
        enr_x <= '0';
        enw_x <= '0';
        addr_rom_x <= to_unsigned(0, 4);
        addr0_x <= to_unsigned(65536, 24);
        addr1_x <= to_unsigned(65537, 24);
        -- writes to sdram at address during the WRITE_HI_BYTE state
        -- 0001 
        -- 
        -- then goes to the READ_HI_AND_SUM_DATA state
        dataToRam0_x <= to_unsigned(1, 32);
        dataToRam1_x <= to_unsigned(32, 32);
        state_x <= WRITE_HI_BYTE;
    else
        case state_r is
            when WRITE_HI_BYTE =>
                -- writes to sdram at address 
                -- 0x020000 0001 hi byte of 65568
                -- until the address 65554
                -- then goes to the WRITE_LO_BYTE state
                if (done0_s = '0') then
                    wr0_s <= '1';
                elsif (addr0_r <= 65554) then
                    dataToRam0_x <= dataToRam0_r;
                    addr0_x <= (addr0_r + 2);
                else
                    addr1_x <= to_unsigned(65537, 24);
                    sum_x <= to_unsigned(0, 32);
                    state_x <= WRITE_LO_BYTE;
                end if;
            when WRITE_LO_BYTE =>
                -- writes to sdram at address 
                -- 0x020001 0020 lo byte
                -- then goes to the WRITE_LO_BYTE state
                if (done1_s = '0') then
                    wr1_s <= '1';
                elsif (addr1_r <= 65555) then
                    dataToRam1_x <= (dataToRam1_r + 1);
                    addr1_x <= (addr1_r + 2);
                else
                    addr0_x <= to_unsigned(65536, 24);
                    addr1_x <= to_unsigned(65537, 24);
                    sum_x <= to_unsigned(0, 32);
                    state_x <= READ_LO_AND_SUM_DATA;
                end if;
            when others =>
                if (state_r = READ_HI_AND_SUM_DATA) then
                    if (done0_s = '0') then
                        rd0_s <= '1';
                    elsif (addr0_r <= 65554) then
                        sum_x <= (sum_r + shift_left(dataFromRam0_s, 16));
                        addr0_x <= (addr0_r + 2);
                    else
                        addr0_x <= to_unsigned(65536, 24);
                        state_x <= INIT;
                    end if;
                elsif (state_r = READ_LO_AND_SUM_DATA) then
                    if (done1_s = '0') then
                        rd1_s <= '1';
                    elsif (addr1_r <= 65555) then
                        sum_x <= (sum_r + dataFromRam1_s);
                        addr1_x <= (addr1_r + 2);
                    else
                        addr0_x <= to_unsigned(65536, 24);
                        state_x <= READ_HI_AND_SUM_DATA;
                    end if;
                elsif (state_r = CK_SDRAM_RD) then
                    if (done0_s = '0') then
                        rd0_s <= '1';
                        enw_x <= '0';
                    else
                        if (addr0_r <= 1023) then
                            enw_x <= '1';
                            addr0_x <= (addr0_r + 1);
                            datain_x <= dataFromRam0_s;
                        else
                            addr0_x <= to_unsigned(131072, 24);
                            state_x <= CK_SDRAM_WR;
                        end if;
                    end if;
                elsif (state_r = CK_SDRAM_WR) then
                    if (done0_s = '0') then
                        wr0_s <= '1';
                        enr_x <= '0';
                    elsif (addr0_r <= 132095) then
                        enr_x <= '1';
                        dataToRam0_x <= dataout_r;
                        addr0_x <= (addr0_r + 1);
                    else
                        state_x <= DONE;
                    end if;
                elsif (state_r = ODD_SAMPLES) then
                    if (done0_s = '0') then
                        rd0_s <= '1';
                        reset_col <= '0';
                    else
                        if (row_r <= 254) then
                            reset_col <= '1';
                            if (row_r = 254) then
                                if (col_r <= 254) then
                                    row_x <= to_unsigned(0, 8);
                                    offset_x <= (offset_r - 65022);
                                    col_x <= (col_r + 1);
                                else
                                    offset_x <= to_unsigned(0, 24);
                                    row_x <= to_unsigned(0, 8);
                                    col_x <= to_unsigned(0, 8);
                                    state_x <= DONE;
                                end if;
                            end if;
                        end if;
                    end if;
                elsif (state_r = READ_ROM_TO_FIFO) then
                    enw_x <= '1';
                    if (offset_r <= 16) then
                        offset_x <= (offset_r + 1);
                        addr_rom_x <= (addr_rom_r + 1);
                        datain_x <= dout_rom;
                    else
                        enw_x <= '0';
                        addr0_x <= to_unsigned(0, 24);
                        state_x <= WRITE_FIFO_TO_SDRAM;
                    end if;
                elsif (state_r = WRITE_FIFO_TO_SDRAM) then
                    if (done0_s = '0') then
                        wr0_s <= '1';
                        enr_x <= '1';
                    elsif (addr0_r <= 16) then
                        addr0_x <= (addr0_r + 1);
                        dataToRam0_x <= dataout_r;
                    else
                        enr_x <= '0';
                        addr0_x <= to_unsigned(0, 24);
                        offset_x <= to_unsigned(0, 24);
                        row_x <= to_unsigned(0, 8);
                        index2_x <= to_unsigned(1, 24);
                        index2_x <= to_unsigned(257, 24);
                        index3_x <= to_unsigned(513, 24);
                        state_x <= INIT;
                    end if;
                elsif (state_r = EVEN_SAMPLES) then
                    if (done0_s = '0') then
                        rd0_s <= '1';
                        reset_col <= '0';
                        enw_x <= '0';
                    else
                        if (row_r <= 254) then
                            reset_col <= '1';
                            addr0_x <= (offset_r + 1);
                            offset_x <= (offset_r + 256);
                            row_x <= (row_r + 1);
                            if (addr0_r = TEST1) then
                                index1_x <= (index1_r + 768);
                            end if;
                            if (addr0_r = TEST2) then
                                index2_x <= (index2_r + 768);
                            end if;
                            if (addr0_r = TEST3) then
                                index3_x <= (index3_r + 768);
                            end if;
                        else
                            offset_x <= (offset_r - 65278);
                            index1_x <= (index1_r - 65278);
                            index2_x <= (index2_r - 65278);
                            index3_x <= (index3_r - 64510);
                            row_x <= to_unsigned(0, 8);
                            col_x <= (col_r + 1);
                            if (col_r = 254) then
                                state_x <= INIT;
                            end if;
                        end if;
                    end if;
                elsif (state_r = WR_DATA) then
                    if (addr0_r = 1) then
                        addr0_x <= to_unsigned(8, 24);
                    else
                        state_x <= DONE;
                    end if;
                elsif (state_r = INTERLACE) then
                    if (addr0_r = 16) then
                        state_x <= DONE;
                    end if;
                elsif (state_r = COPY_PG1_TO_PG2) then
                    if ((done1_s = '0') and (done0_s = '0')) then
                        rd1_s <= '1';
                        wr0_s <= '1';
                    else
                        if (addr1_r <= 131071) then
                            -- Read from address pointed by addr1_r
                            -- Write to address pointed by addr0_r
                            -- next state READ_AND_SUM_DATA from Pg2
                            dataToRam0_x <= dataFromRam1_s;
                            addr1_x <= (addr1_r + 1);
                            addr0_x <= (addr0_r + 1);
                        else
                            addr0_x <= to_unsigned(131072, 24);
                            state_x <= INIT;
                        end if;
                    end if;
                elsif (state_r = DONE) then
                    state_x <= INIT;
                end if;
        end case;
    end if;
end process XESS_JPEG_TOP_INSTANCE_6_FSM;


XESS_JPEG_TOP_INSTANCE_7_FSMUPDATE: process (clk_fast) is
begin
    if rising_edge(clk_fast) then
        addr0_r <= addr0_x;
        dataToRam0_r <= dataToRam0_x;
        dataFromRam0_r <= dataFromRam0_x;
        addr1_r <= addr1_x;
        dataToRam1_r <= dataToRam1_x;
        dataFromRam1_r <= dataFromRam1_x;
        state_r <= state_x;
        sum_r <= sum_x;
        empty_r <= empty_x;
        full_r <= full_x;
        enr_r <= enr_x;
        enw_r <= enw_x;
        dataout_r <= dataout_x;
        datain_r <= datain_x;
        offset_r <= offset_x;
        col_r <= col_x;
        row_r <= row_x;
        addr_rom_r <= addr_rom_x;
        index1_r <= index1_x;
        index2_r <= index2_x;
        index3_r <= index3_x;
    end if;
end process XESS_JPEG_TOP_INSTANCE_7_FSMUPDATE;


XESS_JPEG_TOP_INSTANCE_8_READ: process (addr_rom_r) is
begin
    case to_integer(addr_rom_r) is
        when 0 => dout_rom <= "00111010100100010100100010100100";
        when 1 => dout_rom <= "00111010011100010011100010100100";
        when 2 => dout_rom <= "00111010100100010011100010011100";
        when 3 => dout_rom <= "00111010011100010011100010100100";
        when 4 => dout_rom <= "00111010011100010011100010011100";
        when 5 => dout_rom <= "00111010011100010011100010011100";
        when 6 => dout_rom <= "00111010011100010011100010011100";
        when 7 => dout_rom <= "00111010011100010011100010011100";
        when 8 => dout_rom <= "00111010011100010011100010011100";
        when 9 => dout_rom <= "00111010100100010100100010011100";
        when 10 => dout_rom <= "00111010100100010100100010100100";
        when 11 => dout_rom <= "00111010100100010100100010100100";
        when 12 => dout_rom <= "00111010011100010100100010100100";
        when 13 => dout_rom <= "00111010100100010100100010011100";
        when 14 => dout_rom <= "00111010100100010011100010100100";
        when others => dout_rom <= "00111010100100010101100010100100";
    end case;
end process XESS_JPEG_TOP_INSTANCE_8_READ;

end architecture MyHDL;
