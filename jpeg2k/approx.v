// File: approx.v
// Generated by MyHDL 0.9dev
// Date: Tue Oct  7 12:14:50 2014


`timescale 1ns/10ps

module approx (
    clk_fast,
    even_odd_s,
    left_s,
    sam_s,
    right_s,
    we_lf,
    we_sam,
    we_rht,
    we_res,
    addr_lf,
    addr_sam,
    addr_rht,
    addr_res,
    dout_lf,
    dout_sam,
    dout_rht,
    odd,
    reset_jpeg,
    updated_s
);


input clk_fast;
output even_odd_s;
reg even_odd_s;
output signed [15:0] left_s;
reg signed [15:0] left_s;
output signed [15:0] sam_s;
reg signed [15:0] sam_s;
output signed [15:0] right_s;
reg signed [15:0] right_s;
output we_lf;
reg we_lf;
output we_sam;
reg we_sam;
output we_rht;
reg we_rht;
output we_res;
reg we_res;
output [8:0] addr_lf;
reg [8:0] addr_lf;
output [8:0] addr_sam;
reg [8:0] addr_sam;
output [8:0] addr_rht;
reg [8:0] addr_rht;
output [8:0] addr_res;
reg [8:0] addr_res;
input [15:0] dout_lf;
input [15:0] dout_sam;
input [15:0] dout_rht;
input odd;
input reset_jpeg;
output updated_s;
reg updated_s;






always @(posedge clk_fast) begin: APPROX_XX
    if (reset_jpeg) begin
        updated_s <= 0;
        we_lf <= 0;
        we_sam <= 0;
        we_rht <= 0;
        we_res <= 1;
        if (odd) begin
            addr_lf <= 1;
            addr_sam <= 1;
            addr_rht <= 1;
            addr_res <= 1;
            even_odd_s <= 0;
        end
        else begin
            addr_lf <= 2;
            addr_sam <= 2;
            addr_rht <= 2;
            addr_res <= 2;
            even_odd_s <= 1;
        end
    end
    else begin
        if ((addr_res <= 64)) begin
            left_s <= dout_lf;
            sam_s <= dout_sam;
            right_s <= dout_rht;
            updated_s <= 1;
            if ((updated_s == 0)) begin
                addr_lf <= (addr_lf + 2);
                addr_sam <= (addr_sam + 2);
                addr_rht <= (addr_rht + 2);
                addr_res <= (addr_res + 2);
            end
        end
    end
end

endmodule
