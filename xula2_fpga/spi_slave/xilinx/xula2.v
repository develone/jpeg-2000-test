// File: xula2.v
// Generated by MyHDL 1.0dev
// Date: Fri Apr  8 14:10:47 2016


`timescale 1ns/10ps

module xula2 (
    led,
    clock,
    mosi,
    miso,
    sck
);
// a simple LED blinks example.
// This is intended to be used with the Xula, Stickit motherboard
// and an LED / button pmod board.

input led;
input clock;
input mosi;
input miso;
input sck;

reg fifobus_write;
reg [23:0] cnt;
wire full;
reg reset;
reg [4:0] reset_dly_cnt;
reg toggle;
wire [7:0] fifobus_read_data;
wire fifobus_full;
wire wr;
reg fifobus_read;
reg [7:0] fifobus_write_data;
wire rd;
wire [7:0] data;
wire empty;
wire fifobus_empty;
wire inst_spi_spibus_mosi;
reg [7:0] inst_spi_ireg;
wire inst_spi_csn;
reg inst_spi_gotit;
reg inst_spi_writepath_empty;
wire inst_spi_sck;
reg inst_spi_writepath_read;
reg inst_spi_spi_start;
reg [7:0] inst_spi_readpath_write_data;
wire [7:0] inst_spi_icaps;
reg [7:0] inst_spi_oreg;
reg [7:0] inst_spi_icap;
reg [3:0] inst_spi_bitcnt;
reg inst_spi_spibus_miso;
reg [7:0] inst_spi_ocap;
reg [3:0] inst_spi_b2;
wire [3:0] inst_spi_b3;
wire [7:0] inst_spi_writepath_read_data;
reg inst_spi_readpath_write;
wire inst_spi_mp_fifo_inst_readpath_read;
wire [7:0] inst_spi_mp_fifo_inst_writepath_write_data;
wire inst_spi_mp_fifo_inst_readpath_read_valid;
reg inst_spi_mp_fifo_inst_readpath_empty;
reg inst_spi_mp_fifo_inst_writepath_full;
wire [7:0] inst_spi_mp_fifo_inst_readpath_read_data;
wire inst_spi_mp_fifo_inst_writepath_write;
wire inst_spi_mp_fifo_inst_self_read_valid;
reg [4:0] inst_spi_rx_fifo_inst_nvacant;
reg inst_spi_rx_fifo_inst_fbus_full;
reg [3:0] inst_spi_rx_fifo_inst_addr;
reg [4:0] inst_spi_rx_fifo_inst_ntenant;
wire inst_spi_rx_fifo_inst_fbus_clear;
wire [4:0] inst_spi_rx_fifo_inst_fbus_count;
reg [4:0] inst_spi_tx_fifo_inst_nvacant;
reg [3:0] inst_spi_tx_fifo_inst_addr;
reg [4:0] inst_spi_tx_fifo_inst_ntenant;
wire inst_spi_tx_fifo_inst_fbus_clear;
wire [4:0] inst_spi_tx_fifo_inst_fbus_count;
wire inst_spi_tx_fifo_inst_fbus_read_valid;

reg [3:0] inst_spi_isync2_inst_staps [0:3-1];
reg [7:0] inst_spi_isync1_inst_staps [0:3-1];
reg [7:0] inst_spi_rx_fifo_inst_mem [0:16-1];
reg [7:0] inst_spi_tx_fifo_inst_mem [0:16-1];

assign inst_spi_spibus_mosi = 1'd1;
assign inst_spi_csn = 1'd1;
assign inst_spi_sck = 1'd0;
assign inst_spi_rx_fifo_inst_fbus_clear = 1'd0;
assign inst_spi_tx_fifo_inst_fbus_clear = 1'd0;



always @(posedge clock) begin: XULA2_RTL
    if (($signed({1'b0, cnt}) == (12000000 - 1))) begin
        toggle <= (!toggle);
        cnt <= 0;
    end
    else begin
        cnt <= (cnt + 1);
    end
end


always @(fifobus_full, fifobus_read_data, fifobus_empty) begin: XULA2_TB_FIFO_LOOPBACK
    if ((!fifobus_full)) begin
        fifobus_write = (!fifobus_empty);
        fifobus_read = (!fifobus_empty);
        fifobus_write_data = fifobus_read_data;
    end
end


always @(posedge clock) begin: XULA2_INST_SPI_BEH_IO_CAPTURE
    inst_spi_readpath_write <= 1'b0;
    inst_spi_writepath_read <= 1'b0;
    if ((inst_spi_b3 == 0)) begin
        inst_spi_gotit <= 1'b0;
    end
    else if (((inst_spi_b3 == 8) && (!inst_spi_gotit))) begin
        inst_spi_readpath_write <= 1'b1;
        inst_spi_readpath_write_data <= inst_spi_icaps;
        inst_spi_gotit <= 1'b1;
        inst_spi_ocap <= inst_spi_writepath_read_data;
        if ((!inst_spi_writepath_empty)) begin
            inst_spi_writepath_read <= 1'b1;
        end
    end
end



assign inst_spi_b3 = inst_spi_isync2_inst_staps[(3 - 1)];


always @(posedge clock) begin: XULA2_INST_SPI_ISYNC2_INST_BEH_SYNC_STAGES
    integer ii;
    inst_spi_isync2_inst_staps[0] <= inst_spi_b2;
    for (ii=1; ii<3; ii=ii+1) begin
        inst_spi_isync2_inst_staps[ii] <= inst_spi_isync2_inst_staps[(ii - 1)];
    end
end


always @(posedge inst_spi_sck, posedge inst_spi_csn) begin: XULA2_INST_SPI_SCK_CAPTURE_SEND
    if (inst_spi_csn) begin
        inst_spi_b2 <= 0;
        inst_spi_bitcnt <= 0;
    end
    else begin
        if (((inst_spi_bitcnt == 0) || inst_spi_spi_start)) begin
            inst_spi_spibus_miso <= inst_spi_ocap[7];
            inst_spi_oreg <= ((inst_spi_ocap << 1) & 255);
        end
        else begin
            inst_spi_spibus_miso <= inst_spi_oreg[7];
            inst_spi_oreg <= ((inst_spi_oreg << 1) & 255);
        end
        inst_spi_ireg <= {inst_spi_ireg[7-1:0], inst_spi_spibus_mosi};
        inst_spi_bitcnt <= (inst_spi_bitcnt + 1);
        if (($signed({1'b0, inst_spi_bitcnt}) == (8 - 1))) begin
            inst_spi_bitcnt <= 0;
            inst_spi_b2 <= 8;
            inst_spi_icap <= {inst_spi_ireg[7-1:0], inst_spi_spibus_mosi};
        end
        else begin
            inst_spi_b2 <= 0;
        end
    end
end


always @(posedge clock) begin: XULA2_INST_SPI_TX_FIFO_INST_RTL_OCCUPANCY
    if (reset == 1) begin
        inst_spi_tx_fifo_inst_nvacant <= 16;
        inst_spi_tx_fifo_inst_ntenant <= 0;
    end
    else begin
        if (inst_spi_tx_fifo_inst_fbus_clear) begin
            inst_spi_tx_fifo_inst_nvacant <= 16;
            inst_spi_tx_fifo_inst_ntenant <= 0;
        end
        else if ((inst_spi_writepath_read && (!inst_spi_mp_fifo_inst_writepath_write))) begin
            inst_spi_tx_fifo_inst_nvacant <= (inst_spi_tx_fifo_inst_nvacant + 1);
            inst_spi_tx_fifo_inst_ntenant <= (inst_spi_tx_fifo_inst_ntenant - 1);
        end
        else if ((inst_spi_mp_fifo_inst_writepath_write && (!inst_spi_writepath_read))) begin
            inst_spi_tx_fifo_inst_nvacant <= (inst_spi_tx_fifo_inst_nvacant - 1);
            inst_spi_tx_fifo_inst_ntenant <= (inst_spi_tx_fifo_inst_ntenant + 1);
        end
    end
end



assign inst_spi_writepath_read_data = inst_spi_tx_fifo_inst_mem[inst_spi_tx_fifo_inst_addr];



assign inst_spi_tx_fifo_inst_fbus_count = inst_spi_tx_fifo_inst_ntenant;



assign inst_spi_tx_fifo_inst_fbus_read_valid = (inst_spi_writepath_read && (!inst_spi_writepath_empty));


always @(posedge clock) begin: XULA2_INST_SPI_TX_FIFO_INST_RTL_FIFO
    if (reset == 1) begin
        inst_spi_mp_fifo_inst_writepath_full <= 0;
        inst_spi_writepath_empty <= 1;
        inst_spi_tx_fifo_inst_addr <= 0;
    end
    else begin
        if (inst_spi_tx_fifo_inst_fbus_clear) begin
            inst_spi_tx_fifo_inst_addr <= 0;
            inst_spi_writepath_empty <= 1'b1;
            inst_spi_mp_fifo_inst_writepath_full <= 1'b0;
        end
        else if ((inst_spi_writepath_read && (!inst_spi_mp_fifo_inst_writepath_write))) begin
            inst_spi_mp_fifo_inst_writepath_full <= 1'b0;
            if ((inst_spi_tx_fifo_inst_addr == 0)) begin
                inst_spi_writepath_empty <= 1'b1;
            end
            else begin
                inst_spi_tx_fifo_inst_addr <= (inst_spi_tx_fifo_inst_addr - 1);
            end
        end
        else if ((inst_spi_mp_fifo_inst_writepath_write && (!inst_spi_writepath_read))) begin
            inst_spi_writepath_empty <= 1'b0;
            if ((!inst_spi_writepath_empty)) begin
                inst_spi_tx_fifo_inst_addr <= (inst_spi_tx_fifo_inst_addr + 1);
            end
            if (($signed({1'b0, inst_spi_tx_fifo_inst_addr}) == (16 - 2))) begin
                inst_spi_mp_fifo_inst_writepath_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: XULA2_INST_SPI_TX_FIFO_INST_RTL_SRL_IN
    integer jj;
    if (inst_spi_mp_fifo_inst_writepath_write) begin
        inst_spi_tx_fifo_inst_mem[0] <= inst_spi_mp_fifo_inst_writepath_write_data;
        for (jj=1; jj<16; jj=jj+1) begin
            inst_spi_tx_fifo_inst_mem[jj] <= inst_spi_tx_fifo_inst_mem[(jj - 1)];
        end
    end
end


always @(posedge clock) begin: XULA2_INST_SPI_RX_FIFO_INST_RTL_OCCUPANCY
    if (reset == 1) begin
        inst_spi_rx_fifo_inst_nvacant <= 16;
        inst_spi_rx_fifo_inst_ntenant <= 0;
    end
    else begin
        if (inst_spi_rx_fifo_inst_fbus_clear) begin
            inst_spi_rx_fifo_inst_nvacant <= 16;
            inst_spi_rx_fifo_inst_ntenant <= 0;
        end
        else if ((inst_spi_mp_fifo_inst_readpath_read && (!inst_spi_readpath_write))) begin
            inst_spi_rx_fifo_inst_nvacant <= (inst_spi_rx_fifo_inst_nvacant + 1);
            inst_spi_rx_fifo_inst_ntenant <= (inst_spi_rx_fifo_inst_ntenant - 1);
        end
        else if ((inst_spi_readpath_write && (!inst_spi_mp_fifo_inst_readpath_read))) begin
            inst_spi_rx_fifo_inst_nvacant <= (inst_spi_rx_fifo_inst_nvacant - 1);
            inst_spi_rx_fifo_inst_ntenant <= (inst_spi_rx_fifo_inst_ntenant + 1);
        end
    end
end



assign inst_spi_mp_fifo_inst_readpath_read_data = inst_spi_rx_fifo_inst_mem[inst_spi_rx_fifo_inst_addr];



assign inst_spi_rx_fifo_inst_fbus_count = inst_spi_rx_fifo_inst_ntenant;



assign inst_spi_mp_fifo_inst_readpath_read_valid = (inst_spi_mp_fifo_inst_readpath_read && (!inst_spi_mp_fifo_inst_readpath_empty));


always @(posedge clock) begin: XULA2_INST_SPI_RX_FIFO_INST_RTL_FIFO
    if (reset == 1) begin
        inst_spi_rx_fifo_inst_fbus_full <= 0;
        inst_spi_mp_fifo_inst_readpath_empty <= 1;
        inst_spi_rx_fifo_inst_addr <= 0;
    end
    else begin
        if (inst_spi_rx_fifo_inst_fbus_clear) begin
            inst_spi_rx_fifo_inst_addr <= 0;
            inst_spi_mp_fifo_inst_readpath_empty <= 1'b1;
            inst_spi_rx_fifo_inst_fbus_full <= 1'b0;
        end
        else if ((inst_spi_mp_fifo_inst_readpath_read && (!inst_spi_readpath_write))) begin
            inst_spi_rx_fifo_inst_fbus_full <= 1'b0;
            if ((inst_spi_rx_fifo_inst_addr == 0)) begin
                inst_spi_mp_fifo_inst_readpath_empty <= 1'b1;
            end
            else begin
                inst_spi_rx_fifo_inst_addr <= (inst_spi_rx_fifo_inst_addr - 1);
            end
        end
        else if ((inst_spi_readpath_write && (!inst_spi_mp_fifo_inst_readpath_read))) begin
            inst_spi_mp_fifo_inst_readpath_empty <= 1'b0;
            if ((!inst_spi_mp_fifo_inst_readpath_empty)) begin
                inst_spi_rx_fifo_inst_addr <= (inst_spi_rx_fifo_inst_addr + 1);
            end
            if (($signed({1'b0, inst_spi_rx_fifo_inst_addr}) == (16 - 2))) begin
                inst_spi_rx_fifo_inst_fbus_full <= 1'b1;
            end
        end
    end
end


always @(posedge clock) begin: XULA2_INST_SPI_RX_FIFO_INST_RTL_SRL_IN
    integer jj;
    if (inst_spi_readpath_write) begin
        inst_spi_rx_fifo_inst_mem[0] <= inst_spi_readpath_write_data;
        for (jj=1; jj<16; jj=jj+1) begin
            inst_spi_rx_fifo_inst_mem[jj] <= inst_spi_rx_fifo_inst_mem[(jj - 1)];
        end
    end
end



assign inst_spi_mp_fifo_inst_writepath_write = fifobus_write;
assign inst_spi_mp_fifo_inst_writepath_write_data = fifobus_write_data;
assign fifobus_full = inst_spi_mp_fifo_inst_writepath_full;
assign inst_spi_mp_fifo_inst_readpath_read = fifobus_read;
assign fifobus_read_data = inst_spi_mp_fifo_inst_readpath_read_data;
assign inst_spi_mp_fifo_inst_self_read_valid = inst_spi_mp_fifo_inst_readpath_read_valid;
assign fifobus_empty = inst_spi_mp_fifo_inst_readpath_empty;



assign inst_spi_icaps = inst_spi_isync1_inst_staps[(3 - 1)];


always @(posedge clock) begin: XULA2_INST_SPI_ISYNC1_INST_BEH_SYNC_STAGES
    integer ii;
    inst_spi_isync1_inst_staps[0] <= inst_spi_icap;
    for (ii=1; ii<3; ii=ii+1) begin
        inst_spi_isync1_inst_staps[ii] <= inst_spi_isync1_inst_staps[(ii - 1)];
    end
end


always @(posedge inst_spi_sck, negedge inst_spi_csn) begin: XULA2_INST_SPI_CSN_FALLS
    if (inst_spi_sck) begin
        inst_spi_spi_start <= 1'b0;
    end
    else if ((!inst_spi_csn)) begin
        inst_spi_spi_start <= 1'b1;
    end
end

// For the first 4 clocks the reset is forced to lo
// for clock 6 to 31 the reset is set hi
// then the reset is lo
always @(posedge clock) begin: XULA2_RESET_TST
    if ((reset_dly_cnt < 31)) begin
        reset_dly_cnt <= (reset_dly_cnt + 1);
        if ((reset_dly_cnt <= 4)) begin
            reset <= 0;
        end
        if ((reset_dly_cnt >= 5)) begin
            reset <= 1;
        end
    end
    else begin
        reset <= 0;
    end
end



assign data = fifobus_read_data;
assign rd = fifobus_read;
assign wr = fifobus_write;
assign full = fifobus_full;
assign empty = fifobus_empty;

endmodule
