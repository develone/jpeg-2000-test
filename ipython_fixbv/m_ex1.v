// File: m_ex1.v
// Generated by MyHDL 0.9dev
// Date: Tue Jul  1 08:57:00 2014


`timescale 1ns/10ps

module m_ex1 (
    clk,
    p,
    even_odd,
    fwd_inv,
    pix_x2_3,
    pix_x2_2,
    pix_x2_1,
    pix_x4_1,
    pix_x4_3,
    pix_x4_2,
    pix_x3_2,
    pix_d3,
    pix_x3_1,
    pix_d3_3,
    pix_x5_1,
    pix_x5_2,
    pix_x5_3,
    pix_a2_3,
    pix_x3_3,
    pix_a2,
    pix_x2,
    pix_x3,
    pix_x4,
    pix_x5,
    pix_d3_2,
    pix_a2_1,
    pix_a2_2,
    pix_d3_1
);


input clk;
input p;
input even_odd;
input fwd_inv;
input signed [31:0] pix_x2_3;
input signed [31:0] pix_x2_2;
input signed [31:0] pix_x2_1;
input signed [31:0] pix_x4_1;
input signed [31:0] pix_x4_3;
input signed [31:0] pix_x4_2;
input signed [31:0] pix_x3_2;
output signed [31:0] pix_d3;
reg signed [31:0] pix_d3;
input signed [31:0] pix_x3_1;
output signed [31:0] pix_d3_3;
reg signed [31:0] pix_d3_3;
input signed [31:0] pix_x5_1;
input signed [31:0] pix_x5_2;
input signed [31:0] pix_x5_3;
output signed [31:0] pix_a2_3;
reg signed [31:0] pix_a2_3;
input signed [31:0] pix_x3_3;
output signed [31:0] pix_a2;
reg signed [31:0] pix_a2;
input signed [31:0] pix_x2;
input signed [31:0] pix_x3;
input signed [31:0] pix_x4;
input signed [31:0] pix_x5;
output signed [31:0] pix_d3_2;
reg signed [31:0] pix_d3_2;
output signed [31:0] pix_a2_1;
reg signed [31:0] pix_a2_1;
output signed [31:0] pix_a2_2;
reg signed [31:0] pix_a2_2;
output signed [31:0] pix_d3_1;
reg signed [31:0] pix_d3_1;

wire [31:0] ca3;
wire [31:0] ca2;
wire [31:0] ca1;
wire [31:0] ca4;
wire [31:0] ra4;
wire [31:0] ra3;
wire [31:0] ra1;
wire [31:0] ra2;


assign ca3 = 6291456;
assign ca2 = -524288;
assign ca1 = -14680064;
assign ca4 = 3145728;
assign ra4 = -4194304;
assign ra3 = -8388608;
assign ra1 = 12582912;
assign ra2 = 393216;



always @(posedge clk) begin: M_EX1_HDL
    if ((!p)) begin
        if (even_odd) begin
            if (fwd_inv) begin
                // p false 1st pass even_odd True fwd_inv True (x2+x3) * ca1 
                pix_d3 <= ((pix_x2 + pix_x3) * ca1);
                pix_d3_1 <= ((pix_x2_1 + pix_x3_1) * ca1);
                pix_d3_2 <= ((pix_x2_2 + pix_x3_2) * ca1);
                pix_d3_3 <= ((pix_x2_2 + pix_x3_2) * ca1);
            end
            else begin
                // p false 1st pass even_odd True fwd_inv False (x4+x5) * ra4 
                pix_a2 <= ((pix_x4 + pix_x5) * ra4);
                pix_a2_1 <= ((pix_x4_1 + pix_x5_1) * ra4);
                pix_a2_2 <= ((pix_x4_2 + pix_x5_2) * ra4);
                pix_a2_3 <= ((pix_x4_3 + pix_x5_3) * ra4);
            end
        end
        else begin
            if (fwd_inv) begin
                // p false 1st pass even_odd false fwd_inv True (x4+x5) * ca2 
                pix_a2 <= ((pix_x4 + pix_x5) * ca2);
                pix_a2_1 <= ((pix_x4_1 + pix_x5_1) * ca2);
                pix_a2_2 <= ((pix_x4_2 + pix_x5_2) * ca2);
                pix_a2_3 <= ((pix_x4_3 + pix_x5_3) * ca2);
            end
            else begin
                // p false 1st pass even_odd false fwd_inv False (x2+x3) * ra3 
                pix_d3 <= ((pix_x2 + pix_x3) * ra3);
                pix_d3_1 <= ((pix_x2_1 + pix_x3_1) * ra3);
                pix_d3_2 <= ((pix_x2_2 + pix_x3_2) * ra3);
                pix_d3_3 <= ((pix_x2_2 + pix_x3_3) * ra3);
            end
        end
    end
    else begin
        if (even_odd) begin
            if (fwd_inv) begin
                // p True 2nd pass even_odd True fwd_inv True (x2+x3) * ca3 
                pix_d3 <= ((pix_x2 + pix_x3) * ca3);
                pix_d3_1 <= ((pix_x2_1 + pix_x3_1) * ca3);
                pix_d3_2 <= ((pix_x2_2 + pix_x3_2) * ca3);
                pix_d3_3 <= ((pix_x2_3 + pix_x3_3) * ca3);
            end
            else begin
                // p True 2nd pass even_odd True fwd_inv False (x4+x5) * ra2 
                pix_a2 <= ((pix_x4 + pix_x5) * ra2);
                pix_a2_1 <= ((pix_x4_1 + pix_x5_1) * ra2);
                pix_a2_2 <= ((pix_x4_2 + pix_x5_2) * ra2);
                pix_a2_3 <= ((pix_x4_3 + pix_x5_3) * ra2);
            end
        end
        else begin
            if (fwd_inv) begin
                // p True 2nd pass even_odd False fwd_inv True (x2+x3) * ca4 
                pix_a2 <= ((pix_x4 + pix_x5) * ca4);
                pix_a2_1 <= ((pix_x4_1 + pix_x5_1) * ca4);
                pix_a2_2 <= ((pix_x4_2 + pix_x5_2) * ca4);
                pix_a2_3 <= ((pix_x4_3 + pix_x5_3) * ca4);
            end
            else begin
                // p True 2nd pass even_odd False fwd_inv False (x2+x3) * ra1 
                pix_d3 <= ((pix_x2 + pix_x3) * ra1);
                pix_d3_1 <= ((pix_x2_1 + pix_x3_1) * ra1);
                pix_d3_2 <= ((pix_x2_2 + pix_x3_2) * ra1);
                pix_d3_3 <= ((pix_x2_3 + pix_x3_3) * ra1);
            end
        end
    end
end

endmodule
