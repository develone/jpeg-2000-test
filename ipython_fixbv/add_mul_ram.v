// File: add_mul_ram.v
// Generated by MyHDL 0.9dev
// Date: Tue Jul  8 17:53:00 2014


`timescale 1ns/10ps

module add_mul_ram (
    clk,
    pix_addr_r,
    pix_right,
    pix_din_r,
    pix_we_r,
    pix_dout_r,
    pix_we_even,
    pix_dout_l,
    pix_din_l,
    pix_p,
    pix_addr_odd,
    pix_fwd_inv,
    pix_we_l,
    pix_addr_l,
    pix_addr_even,
    pix_din_even,
    pix_we_odd,
    pix_dout_odd,
    pix_din_odd,
    pix_dout_even,
    pix_even_odd,
    pix_left
);


input clk;
input [6:0] pix_addr_r;
input signed [25:0] pix_right;
input signed [25:0] pix_din_r;
input pix_we_r;
input signed [25:0] pix_dout_r;
input pix_we_even;
input signed [25:0] pix_dout_l;
input signed [25:0] pix_din_l;
input pix_p;
input [6:0] pix_addr_odd;
input pix_fwd_inv;
input pix_we_l;
input [6:0] pix_addr_l;
input [6:0] pix_addr_even;
output signed [25:0] pix_din_even;
reg signed [25:0] pix_din_even;
input pix_we_odd;
input signed [25:0] pix_dout_odd;
output signed [25:0] pix_din_odd;
reg signed [25:0] pix_din_odd;
input signed [25:0] pix_dout_even;
input pix_even_odd;
input signed [25:0] pix_left;






always @(posedge clk) begin: ADD_MUL_RAM_HDL
    reg signed [26-1:0] ca3;
    reg signed [26-1:0] ca2;
    reg signed [26-1:0] ca1;
    reg signed [26-1:0] ca4;
    reg signed [26-1:0] ra4;
    reg signed [26-1:0] ra2;
    reg signed [26-1:0] ra3;
    reg signed [26-1:0] ra1;
    if ((!pix_p)) begin
        // p False 1st pass even_odd True fwd_inv True * ca2 
        if (pix_even_odd) begin
            if (pix_fwd_inv) begin
                pix_din_even <= ((pix_left + pix_right) * ca2);
            end
            else begin
                pix_din_even <= ((pix_left + pix_right) * ra4);
            end
        end
        else begin
            if (pix_fwd_inv) begin
                pix_din_odd <= ((pix_left + pix_right) * ca1);
            end
            else begin
                pix_din_odd <= ((pix_left + pix_right) * ra3);
            end
        end
    end
    else begin
        // p True 2nd pass even_odd True fwd_inv True * ca4 
        if (pix_even_odd) begin
            if (pix_fwd_inv) begin
                pix_din_even <= ((pix_left + pix_right) * ca4);
            end
            else begin
                pix_din_even <= ((pix_left + pix_right) * ra2);
            end
        end
        else begin
            if (pix_fwd_inv) begin
                pix_din_odd <= ((pix_left + pix_right) * ca3);
            end
            else begin
                pix_din_odd <= ((pix_left + pix_right) * ra1);
            end
        end
    end
end

endmodule
