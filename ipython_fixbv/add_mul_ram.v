// File: add_mul_ram.v
// Generated by MyHDL 0.9dev
// Date: Fri Jul 11 11:08:10 2014


`timescale 1ns/10ps

module add_mul_ram (
    clk,
    pix_dout_even1,
    pix_right,
    pix_left1,
    pix_addr_odd1,
    pix_addr_even1,
    pix_we_even,
    pix_addr_even,
    pix_right1,
    pix_dout_odd1,
    pix_din_even1,
    pix_dout_odd,
    pix_din_odd,
    pix_even_odd,
    pix_we_even1,
    pix_din_odd1,
    pix_fwd_inv,
    pix_din_even,
    pix_dout_even,
    pix_we_odd1,
    pix_p,
    pix_addr_odd,
    pix_we_odd,
    pix_left
);


input clk;
input signed [19:0] pix_dout_even1;
input signed [19:0] pix_right;
input signed [19:0] pix_left1;
input [6:0] pix_addr_odd1;
input [6:0] pix_addr_even1;
input pix_we_even;
input [6:0] pix_addr_even;
input signed [19:0] pix_right1;
input signed [19:0] pix_dout_odd1;
output signed [19:0] pix_din_even1;
reg signed [19:0] pix_din_even1;
input signed [19:0] pix_dout_odd;
output signed [19:0] pix_din_odd;
reg signed [19:0] pix_din_odd;
input pix_even_odd;
input pix_we_even1;
output signed [19:0] pix_din_odd1;
reg signed [19:0] pix_din_odd1;
input pix_fwd_inv;
output signed [19:0] pix_din_even;
reg signed [19:0] pix_din_even;
input signed [19:0] pix_dout_even;
input pix_we_odd1;
input pix_p;
input [6:0] pix_addr_odd;
input pix_we_odd;
input signed [19:0] pix_left;






always @(posedge clk) begin: ADD_MUL_RAM_HDL
    reg signed [38-1:0] ca3;
    reg signed [38-1:0] ca2;
    reg signed [38-1:0] ca1;
    reg signed [38-1:0] ca4;
    reg signed [38-1:0] ra4;
    reg signed [38-1:0] ra2;
    reg signed [38-1:0] ra3;
    reg signed [38-1:0] ra1;
    if ((!pix_p)) begin
        // p False 1st pass even_odd True fwd_inv True 4 inputs
        // left & right are added and mul by ca2  
        // left1 & right1 are added and mul by ca2
        // results are stored in two ram_even & ram_even1 
        // 
        // p False 1st pass even_odd False fwd_inv True 4 inputs
        // left & right are added and mul by ca1  
        // left1 & right1 are added and mul by ca1
        // results are stored in two ram_odd & ram_odd1 
        // 
        // p False 1st pass even_odd True fwd_inv False 4 inputs
        // left & right are added and mul by ra4
        // left1 & right1 are added and mul by ra4
        // results are stored in two ram_even & ram_even1 
        // 
        // p False 1st pass even_odd False fwd_inv False 4 inputs
        // left & right are added and mul by ra3
        // left1 & right1 are added and mul by ra3
        // results are stored in two ram_odd & ram_odd1 
        if (pix_even_odd) begin
            if (pix_fwd_inv) begin
                pix_din_even <= ((pix_left + pix_right) * ca1);
                pix_din_even1 <= ((pix_left1 + pix_right1) * ca1);
            end
            else begin
                pix_din_even <= ((pix_left + pix_right) * ra4);
                pix_din_even1 <= ((pix_left1 + pix_right1) * ra4);
            end
        end
        else begin
            if (pix_fwd_inv) begin
                pix_din_odd <= ((pix_left + pix_right) * ca2);
                pix_din_odd1 <= ((pix_left1 + pix_right1) * ca2);
            end
            else begin
                pix_din_odd <= ((pix_left + pix_right) * ra3);
                pix_din_odd1 <= ((pix_left1 + pix_right1) * ra3);
            end
        end
    end
    else begin
        // p True 1st pass even_odd True fwd_inv True 4 inputs
        // left & right are added and mul by ca4 
        // left1 & right1 are added and mul by ca4
        // results are stored in two ram_even & ram_even1 
        // 
        // p True 1st pass even_odd False fwd_inv True 4 inputs
        // left & right are added and mul by ca3
        // left1 & right1 are added and mul by ca3
        // results are stored in two ram_odd & ram_odd1 
        // 
        // p True 1st pass even_odd True fwd_inv False 4 inputs
        // left & right are added and mul by ra2
        // left1 & right1 are added and mul by ra2
        // results are stored in two ram_even & ram_even1 
        // 
        // p True 1st pass even_odd False fwd_inv False 4 inputs
        // left & right are added and mul by ra1
        // left1 & right1 are added and mul by ra1
        // results are stored in two ram_odd & ram_odd1 
        if (pix_even_odd) begin
            if (pix_fwd_inv) begin
                pix_din_even <= ((pix_left + pix_right) * ca3);
                pix_din_even1 <= ((pix_left1 + pix_right1) * ca3);
            end
            else begin
                pix_din_even <= ((pix_left + pix_right) * ra2);
                pix_din_even1 <= ((pix_left1 + pix_right1) * ra2);
            end
        end
        else begin
            if (pix_fwd_inv) begin
                pix_din_odd <= ((pix_left + pix_right) * ca4);
                pix_din_odd1 <= ((pix_left1 + pix_right1) * ca4);
            end
            else begin
                pix_din_odd <= ((pix_left + pix_right) * ra1);
                pix_din_odd1 <= ((pix_left1 + pix_right1) * ra1);
            end
        end
    end
end

endmodule
