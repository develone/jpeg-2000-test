09/08/14
chgs required
need to fix 12 should be 0
need to fix 211 should be 254
need to move 
 if std_logic(even_odd_s) = YES then
   result_x <= std_logic_vector(sam_r - (shift_right(left_r, 1) + shift_right(right_r, 1)));
 else 
   result_x <= std_logic_vector(sam_r + shift_right(((left_r + right_r) + 2), 2));
 end if;

clean up --use work.pck_myhdl_09.all;

need to return result_r instead of sumDut_s
sumDut_s <= std_logic_vector(result_r);

removed jpeg.vhd & pck_myhdl_09.vhd
if even_odd_s = NO then
					result_x <= std_logic_vector(sam_r - (shift_right(left_r, 1) + shift_right(right_r, 1)));
				 else 
				   result_x <= std_logic_vector(sam_r + shift_right(((left_r + right_r) + 2), 2));
				 end if;
chgs pc_jpeg_sig.py
needed to determine the values of even_odd & fwd_inv sent

jpeg = XsDut(USB_ID, JPEG_ID, [1, 1], [16, 16, 16, 16, 16, 1, 1])
lift , sum, left, sam, right, e_ret, f_ret = jpeg.Exec(even_odd, fwd_inv)  # Use the jpeg in FPGA.
print lift.int, sum.int, left.int, sam.int, right.int, e_ret, f_ret
##################################################################
# This program tests the interface between the host PC and the FPGA 
# on the XuLA board that has been programmed to act as a jpeg_lifting .
##################################################################

0 1
0 12 166 169 172 0b0 0b1

if std_logic(even_odd_s) = YES then
					result_x <= std_logic_vector(sam_r - (shift_right(left_r, 1) + shift_right(right_r, 1)));
				 else 
				   result_x <= std_logic_vector(sam_r + shift_right(((left_r + right_r) + 2), 2));
				 end if;

##################################################################
# This program tests the interface between the host PC and the FPGA 
# on the XuLA board that has been programmed to act as a jpeg_lifting .
##################################################################

0 1
0 211 166 169 172 0b0 0b1				 
Given the above values for left sam and righ perform the fwd dwt odd should be 0 not 12 or 254 not 211 

09/07/14
modified files
    project_status.txt
    sdramspinst.bit
    SdramSPInst.vhd
    pc_jpeg_sig.py

There is a problem with adding left_r, right_r, sam_r ,left_x, right_x, sam_x since this can only be 0 to natural range 0 to RAM_SIZE_C * (2**RAM_WIDTH_C) - 1;

signal left_r, right_r, sam_r ,left_x, right_x, sam_x : RamWord_t;
Testing with storing -160 at addr 0

constant LEFT_ADDR_C             : natural   := 2;
constant SAM_ADDR_C             : natural   := 3;
constant RIGHT_ADDR_C             : natural   := 4;

:10000000FF60FF63FF66FF69FF6CFF6FFF72008890
:10001000005E0069006B006C006A00750078007D6E
FF66
FF69
FF6C

##################################################################
# This program tests the interface between the host PC and the FPGA 
# on the XuLA board that has been programmed to act as a jpeg_lifting .
##################################################################

0 1
0 -915 65382 65385 65388
09/06/14
chgs to "SdramSPInst.vhd"
checking in the "sdramspinst.bit"

##################################################################
# This program tests the interface between the host PC and the FPGA 
# on the XuLA board that has been programmed to act as a jpeg_lifting .
##################################################################

1 1
0 1005 160 163 166
Now the ram is initialized and 0 1 2 values are sent back
using the "python pc_jpeg_sig.py"

09/05/14
Modified the SdramSPInst to write data
in the range of lena
:1000000000A000A300A600A900AC00AF5500455514
0000 00A0 160
0001 00A3 163
0002 00A6 166
0003 00A9 169
0004 00AC 172
0005 00AF 175

##################################################################
# This program tests the interface between the host PC and the FPGA 
# on the XuLA board that has been programmed to act as a jpeg_lifting .
##################################################################

81 105 390 1 1
-166
-166 1005
