-- File: jpeg.vhd
-- Generated by MyHDL 0.9dev
-- Date: Wed Sep 10 12:19:59 2014


library IEEE,XESS;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;
use XESS.ClkgenPckg.all;     -- For the clock generator module.
use XESS.SdramCntlPckg.all;  -- For the SDRAM controller module.
use XESS.HostIoPckg.all;     -- For the FPGA<=>PC transfer link module.

use work.pck_myhdl_09.all;

entity jpeg is
    port (
	     fpgaClk_i : in    std_logic;  -- 12 MHz clock input from 
        clk_s: in std_logic;
        left_s: in signed (15 downto 0);
        right_s: in signed (15 downto 0);
        sam_s: in signed (15 downto 0);
        res_s: out signed (15 downto 0);
        even_odd_s: in std_logic;
        fwd_inv_s: in std_logic
    );
end entity jpeg;


architecture MyHDL of jpeg is
-- Connections between the shift-register module and  jpeg.
  --    80          70         60        50        40          30        20        10         0
  --   1 0 9876543210987654 3210987654321098 7654321098765432 1098765432109876 5432109876543210
  signal fromjpeg_s : std_logic_vector(81 downto 0); -- From jpeg to PC.
  alias fromresult_s is fromjpeg_s(15 downto 0); -- jpeg output.
  alias fromsum_s is fromjpeg_s(31 downto 16); -- sum_r.
  alias fromleft_s is fromjpeg_s(47 downto 32);  -- jpeg's left pixel
  alias fromsam_s is fromjpeg_s(63 downto 48);  -- jpeg's sam pixel
  alias fromright_s is fromjpeg_s(79 downto 64); --jpeg's right right
  alias fromev_o_s is fromjpeg_s(80);
  alias fromfd_iv_s is fromjpeg_s(81);
  
  signal tojpeg_s : std_logic_vector(1 downto 0); -- From PC to jpeg.
  --signal tojpeg_s : std_logic_vector(49 downto 0); -- From PC to jpeg.
  --signal fromsum_s : std_logic_vector(15 downto 0);
  --signal ev_o_tmp_s : std_logic;
  --signal fd_iv_tmp_s : std_logic;
  alias ev_o_s is tojpeg_s(0);
  alias fd_iv_s is tojpeg_s(1);

 signal inShiftDr_s : std_logic; -- True when bits shift btwn PC & FPGA.
 signal drck_s : std_logic; -- Bit shift clock.
 signal tdi_s : std_logic; -- Bits from host PC to the blinker.
 signal tdo_s : std_logic; -- Bits from blinker to the host PC.
 
  


begin
--*********************************************************************
  -- Generate a 100 MHz clock from the 12 MHz input clock and send it out
  -- to the SDRAM. Then feed it back in to clock the internal logic.
  -- (The Spartan-6 FPGAs are a bit picky about what their DCM outputs
  -- are allowed to drive, so I have to use the clkToLogic_o output to
  -- send the clock signal to the output pin of the FPGA and on to the
  -- SDRAM chip.)
  --*********************************************************************
  --At this point the Sdram has not been instanciated
 --port map(I               => fpgaClk_i, clkToLogic_o => sdClk_o);
  Clkgen_u1 : Clkgen
    generic map (BASE_FREQ_G => 12.0, CLK_MUL_G => 25, CLK_DIV_G => 3)
    port map(I               => fpgaClk_i);
   

   --Need signal clk_s                    : std_logic;  -- Internal
   --
	clk_s <= fpgaClk_i;
-------------------------------------------------------------------------
-- JTAG entry point.
-------------------------------------------------------------------------
-- Main entry point for the JTAG signals between the PC and the FPGA.
UBscanToHostIo : BscanToHostIo
  port map (
    inShiftDr_o => inShiftDr_s,
    drck_o => drck_s,
    tdi_o => tdi_s,
    tdo_i => tdo_s
    );
-------------------------------------------------------------------------
-- Shift-register.
-------------------------------------------------------------------------
-- This is the shift-register module between jpeg and JTAG entry point.
UHostIoToJpeg : HostIoToDut
  generic map (ID_G => "00000100") -- The identifier used by the PC.
    port map (
    -- Connections to the BscanToHostIo JTAG entry-point module.
    inShiftDr_i => inShiftDr_s,
    drck_i => drck_s,
    tdi_i => tdi_s,
    tdo_o => tdo_s,
    -- Connections to jpeg
    vectorToDut_o => tojpeg_s, -- From PC to jpeg sam left right.
    vectorFromDut_i => fromjpeg_s -- From jpeg to PC.
    );




JPEG_HDL: process (clk_s) is
begin
    if rising_edge(clk_s) then
        if bool(even_odd_s) then
            if bool(fwd_inv_s) then
                res_s <= (sam_s - (shift_right(left_s, 1) + shift_right(right_s, 1)));
            else
                res_s <= (sam_s + (shift_right(left_s, 1) + shift_right(right_s, 1)));
            end if;
        else
            if bool(fwd_inv_s) then
                res_s <= (sam_s + shift_right(((left_s + right_s) + 2), 2));
            else
                res_s <= (sam_s - shift_right(((left_s + right_s) + 2), 2));
            end if;
        end if;
    end if;
end process JPEG_HDL;

end architecture MyHDL;
